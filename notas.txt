MySql - senha = admin123 (instalado na porta 3306)	

mysql workbench => Serve para visualizar os dados do MySql

*** Instale o Docker, mas pulei a parte de testes, pois identifiquei que talvez seja necessário algum esforço extra. Preferi deixar para fazer isso mais pra frente.

Spring => franework de injeção de dependência
Spring Boot => Veio para facilitar, padronizada para o Spring. Elimina a configuração em XML
			   Existem conveções que fazem parte do código que definem como o projeto será executado.
			   Essas convensões podem ser customizadas e sobreescritas.
			   O Spring Boot veio para simplificar o gerenciamento de dependências.
			   Basta adicionar o Spring Boot como parent do maven.
			   Ele adiciona um servidor Tomcat na minha aplicação, ao invés de precisar encontrar um containr como JBoss, Jet, Wildfly
			   O JAR da aplicação possui um Tomcat embarcado.
			   Endpont default para health metrics e actuators.
Spring Framwork => Necessitava de um conjunto de arquivos para configuração
Gradle => Ferramenta para fazer o build, ou seja, similar ao Ant e ao Maven.
Kotlin / Groovy => Linguagens de programação que também utilizam o Spring boot, podem trabalhar em conjunto com Java. Todas trabalham com JAR.
Git Bash => It lets you use all git features in command line plus most of standard unix commands.
IntelliJ => IDE Java similar ao Eclipse, desenvolvido pela Jet Brains, mesma empresa criadora do PyCharm
Spring initializr => https://start.spring.io/.  É no initializr que eu defino as características do meu projeto como a versão do spring boot por exemplo. 
												Na verdade ele eu nem precisei utilizar este recurso, pois estou usando o STS.
												Mas poderia fazer desta forma e depois mandar gerar o projeto para depois importar no Eclipse.
No STS, depois de definidos os parâmetros do projeto, precisamos definir os projetos que teremos dependências. 
No caso desse curso, selecionei: Spring Boot devTools e Spring Web
*** Erro ao criar o primeiro projeto: Descobri que o Eclipse (STS) não vem com a ver da library correta. Assim, precisei configurar a minha IDE para utilizar o Java 18.
Fiz isso da seguinte forma: Em Window > Preferences > Installed JREs, cliquei no botão Add, depois Standard VM. Apontei para o diretório da minha JRE. 
Também fui em Em Window > Preferences > Installed JREs > Execution Environments e marquei a versão desejada. 
No projeto > properties > Java Build Path > Na aba Library, Modulepath => Excluí a Library que estava com problema e add Library correta.
 => Alterando src>main>resources>application.properties para application.yml
Motivo: Kubernetes, Docker compose, github actions, trevci utilizam yml
Kubernetes => Sistema de orquestração de contêineres open-source que automatiza a implantação, o dimensionamento e a gestão de aplicações em contêineres.
Docker Compose => Orquestrador de containers da Docker
Maven Archetype => Trata-se de um template para criar uma variedade de estruturas de projetos Java.
Possíveis conflitos no Java => Existir mais de um artefado (no pom.xml artifactId) que irá importar classes / métodos de mesmo nome. 
                               Isso irá ocorrer quando o Maven for carregar suas dependências. Para evitar esse problema, utilizar a tag <exclusions> no pom.xml.
							   Ver exemplo em: https://youtu.be/eSAS5msDD7w
Diferença entre uma aplicação Web e uma API Rest => A aplicação Web, utiliza a anotation @Controller, enquanto a API Rest, utiliza @RestController.
											        No caso da aplicação Web, é retornado um HTML, CSS, JS, etc. Enquando API Rest retorna XML, JSON, etc.
No Rest podemos ter: "Query params" e "Path params"
	"Query params" ou "Query String" => Parâmetros são opcionais, utilizado no método "@RequestParam"
	"Path params" => Parâmetros são obrigatórios, utiliza no método "@PathVariable"
	URL passando parâmetro: http://localhost:8080/greeting?name=Image4ever  ou http://localhost:8080/greeting?name=Image4ever&name2=XXXX (2 parâmetros) 
Lombok - Faz o Getter e Setter de forma automática, porém o Leandro do curso não recomenda. No artigo abaixo, eles não recomendam o uso em projetos JPA.
		https://reflectoring.io/when-to-use-lombok/
@Autowired e @Service - são annotations utilizado para fazer a injeção de dependência de um objeto service na Controller. Para saber mais, acessar o projeto e ver o código.
Mock - É um objeto fictício que imita o comportamento de um objeto real.
JPA - Responsável por fazer a persistência e o mapeamento objeto relacional desde a especificação EJB 3.0.
jpa: hibernate: ddl-auto: => Na configuração do application.yml, utilizamos inicialmente update. Para conhecer mais, acessar https://stackoverflow.com/questions/438146/what-are-the-possible-values-of-the-hibernate-hbm2ddl-auto-configuration-and-wha
Na criação do banco de dados no HeidiSQL, utilizei a Colação latin1_swedish_ci (antes, quando criei com o MySQL Workbench, deixei o default e tomei erro)
Value Object - É o padrão de projeto utilizado para evitar que nosso objeto model, seja exposto para o client. Criamos assim um novo objeto que irá armazenar os nossos dados.
Dozer - É um model mapper, ou seja, utilizado para fazer o mapeamento entre objetos do tipo model. Similar a MapStructure, Orika, ModelMapper, Selma, ... 
		Para mais informações ver: https://dozermapper.github.io/gitbook/documentation/gettingstarted.html
VAR - foi adicionado ao Java na versão 10. Com ele não é preciso informar o tipo da variável, já que o compilador iré definir de forma automática.		
@JsonPropertyOrder - Annotation que tem como objetivo definir a ordem dos atributo / campo
@JsonProperty - Annotation que tem como objetivo alterar o nome do campo / aributo
@JsonIgnore - Omito o campo ao gerar o meu JSon
Migrations com Flyway - Trata-se de um padrão para controlar o caso de diferentes versões do banco de dados. Ou seja, o código é modificado e com isso será necessária uma nova
						alteração no banco de dados e uma possível migração dos dados.
Content Negotiation - Negociação de como os dados serão disponibilizados: XML, YML (Yaml), JSON, CSV, PDF, etc
Server-driven - defini como irá prover a API 
Agent-driven - informa como deseja consumir a API						
HATEOAS - Pré requisito para que a aplicações seja RESTful. Resumindo, o HATEOAS fornece links de outras funcionalidades no retorno do JSON / XML para o cliente
Swagger (Open API) - Framework open source multiplatafora, auxia a desenvolver serviços RESTful. Open API está se tornando um padrão no mercado atual.
				   - A implementação do Open API no Spring pode ser vista em: springdoc-openapi v1.6.9 => https://springdoc.org/
				   

*********************************************************************************************************************************
Estudar final e static
Git Worktree - descobrir como funciona
Estudar testes unitários, ver "DozerConverterTest.java" em br.com.focosolution.unittests.mapper
*********************************************************************************************************************************


senha para e-mail da FocoSolution (paulo.freire)
i4ever_guipla => não
&quilibrio209 => não 




